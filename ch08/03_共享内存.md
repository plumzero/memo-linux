
POSIX 共享内存能够让无关进程共享一个映射区域而无需创建一个相应的映射文件。

很多 UNIX 对于共享内存的实现都采用了文件系统来标识共享内存对象。Linux 使用挂载于 `/dev/shm` 目录下的专用 tmpfs 文件系统。这个文件系统具有内核持久性——它所包含的共享内存对象会一直持久，即使当前不存在任何进程打开它，但这些对象会在系统关闭之后丢失。

系统上 POSIX 共享内存区域占据的内存总量受限于底层的 tmpfs 文件系统的大小。这个文件系统通常会在启动时使用默认大小(如 256MB) 进行挂载。如有必要，超级用户能够通过使用命令 `mount -o remount,size=<num-bytes>` 重新挂载这个文件系统来修改它的大小。

要使用 POSIX 共享内存对象需要完成下列任务:
1. 使用 `shm_open()` 函数创建一个新共享对象或打开一个既有对象。一旦成功，shm_open() 会返回一个引用该对象的文件描述符。
2. 将返回的文件描述符传入 `mmap()` 调用并在其 flags 参数中指定 `MAP_SHARED`。这会将共享内存对象映射进进程的虚拟地址空间。与 mmap() 的其他用法一样，一旦映射了对象之后就能够关闭该文件描述符而不会影响到这个映射。然而，有可能需要将这个文件描述符保持在打开状态以便后续的 `fstat()` 和 `ftruncate()` 调用使用这个文件描述符。

### 创建共享内存对象

创建和打开一个新的共享内存对象或打开一个既有对象。
```c++
  #include <fcntl.h>
  #include <sys/stat.h>
  #include <sys/mman.h>

  int shm_open(const char* name, int oflag, mode_t mode);
```
name 标识出了待创建或待打开的共享内存对象。oflag 参数是一个改变调用行为的位掩码。

| 标记 | 描述 |
|:----|:-----|
| O_CREAT | 对象不存在时创建对象 |
| O_EXCL | 与 O_CREAT 互斥地创建对象 |
| O_RDONLY | 打开只读访问 |
| O_RDWR | 打开读写访问 |
| O_TRUNC | 将对象长度截断为零 |

oflag 参数的用途之一是确定是打开一个既有的共享内存对象还是创建并打开一个新对象。如果 oflag 中不包含 O_CREAT，那么就打开一个既有对象。如果指定了 O_CREAT，那么在对象不存在时就创建对象。同时指定 O_EXCL 和 O_CREAT 能够确保调用者是对象的创建者，如果对象已经存在，那么就返回一个错误(EEXIST)。

oflag 参数还表明了调用进程在共享内存对象上的访问模式，其取值为 O_RDONLY 或 O_RDWR 。

剩下的标记值 O_TRUNC 会导致在成功打开一个既有共享内存对象之后将对象的长截断为零。

mode 参数能取的位值与文件上的权限位值是一样的，mode 中的权限掩码将会根据进程的 umask 来取值。

一个新共享内存对象被创建时其初始长度会被设置为 0。这意味着在创建完一个新共享内存对象之后通常在调用 mmap() 之前需要调用 ftruncate() 来设置对象的大小。在调用完 mmap() 之后可能还需要使用 fruncate() 来根据需求扩大或收缩共享内存对象。在扩展一个共享内存对象时，新增加的字节会自动被初始化为 0 。

在任何时候都可以在 shm_open() 返回的文件描述符上使用 fstat() 以获取一个 stat 结构，该结构的字段会包含与这个共享内存对象相关的信息，包括其大小(st_size)、权限(st_mode)、所有者(st_uid)以及组(st_gid)。

使用 `fchmod()` 和 `fchown()` 能够分别修改共享内存对象的权限和所有权。

[创建共享内存对象示例](t/03_shm_open.cpp)

### 使用共享内存对象

先运行这个程序:
[将数据复制进一个POSIX共享内存对象示例](t/03_copy_to.cpp)

再运行这个程序:
[从一个POSIX共享内存对象中复制数据示例](t/03_copy_from.cpp)

应用程序通常需要使用一些同步技术让进程协调它们对共享内存的访问。

### 删除共享内存对象

SUSv3 要求 POSIX 共享内存对象至少具备内核持久性，即它们会持续存在直到被显式删除或系统重启。

当不再需要一个共享内存对象时就应该使用 shm_unlimk() 删除它。
```c++
  #include <sys/mman.h>

  int shm_unlink(const char* name);
    Returns 0 on success, or -1 on error
```
该函数会删除通过 name 指定的共享内存对象。删除一个共享内存对象不会影响对象的既有映射(它会保持有效直到相应的进程调用 munmap() 或终止)，但会阻止后续的 shm_open() 调用打开这个对象。

一旦所有进程都解除映射这个对象，对象就会被删除，其中的内容会丢失。

[删除共享内存对象示例](t/03_shm_unlink.cpp)

### 文件映射与共享内存

一个共享文件映射的内容会与底层映射文件同步意味着内存区域数据能够在系统重启之间得到持久保存。也即共享文件映射提供了持久性存储，而 POSIX 共享内存对象则避免了在无需持久存储时使用磁盘文件所产生的开销。
