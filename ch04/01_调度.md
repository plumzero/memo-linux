
### 进程优先级(nice值)

Linux 调度进程使用 CPU 的默认模型是循环时间共享。在这种算法中，进程无法直接控制何时使用 CPU 以及使用 CPU 的时间。默认情况下，每个进程轮流使用 CPU 直至时间片被用光或自己自动放弃 CPU(如进行睡眠或执行一个磁盘读取操作)。如果所有进程都正常地使用 CPU，那么它们使用 CPU 的时间差不多是相等的。

进程特性 nice 值允许进程间接地影响内核的调度算法。每个进程都拥有一个 nice 值，其取值范围是 -20(高优先级)~19(低优先级)，默认值为 0。

一般地，在 Linux 系统中，只有 root 进程才能够赋给自己(或其他进程)一个负(高)优先级，非 root 进程只能降低自己的优先级，即赋一个大于默认值 0 的 nice 值。

不过从版本号 2.6.12 的内核开始，Linux 提供了 `RLIMIT_NICE` 资源限制，即允许非特权进程提升 nice 值。非特权进程能够将自己的 nice 值最高提高到公式 `20 - rlim_cur` 指定的值，其中 rlim_cur 是当前的 RLIMIT_NICE 软资源限制。

### 实时进程调度

实时应用对调度器有更加严格的要求，这包括:
- 实时应用必须为外部输入提供担保最大响应时间。在很多情况下，这些担保最大响应时间必须非常短(如低于秒级)。为了满足这种要求，`内核必须提供工具`让高优先级进程能快速地取得 CPU 的控制权，抢占当前运行的所有进程。
- 高优先级进程应该能够保持互斥地访问 CPU 直至它完成或自动释放 CPU 。
- 实时应用应该能够精确地控制其组件进程的调度顺序。

满足上面所有要求的应用程序称为`硬实时应用程序`。但 POSIX 实时进程调度 API 无法满足这些要求，仅仅提供了所谓的软实时，即允许控制调度哪个进程使用 CPU 。

SUSv3 规定的实时进程调度 API 部分满足了这些要求。这个 API 提供了两个实时调度策略: `SCHED_RR` 和 `SCHED_FIFO`。使用这两种策略中任意一种策略进行调度的进程的优先级要高于使用标准循环分享策略来调度的进程。实时调度 API 使用常量 SCHED_OTHER 来标识这种循环时间分享策略。

Linux 提供了 99 个实时优先级，其数值从 1(最低)~99(最高)，并且这个取值范围同时适用于两个实时调度策略。每个策略中的优先级是等价的，如果两个进程拥有相同的优先级，但调度策略却不同，至于到底运行哪个则取决于它们被调度的顺序了。实际上，每个优先级级别都维护着一个可运行的进程队列，下一个运行的进程是从优先级最高的非空队列的队头选取出来的。

在多处理器系统中，各个 CPU 拥有独立的运行队列，并且每个 CPU 的运行队列中的进程的优先级都局限于该队列。如假设一个双处理器系统中运行着三个进程，进程 A 的实时优先级为 20，并且它位于 CPU0 的等待队列中，而该 CPU 当前正在运行优先级为 30 的进程 B，即使 CPU1 正在运行优先级为 10 的进程 C，进程 A 还是需要等待 CPU0。包含多个进程的实时应用可以使用 CPU 亲和力 API 来避免这种调度行为可能引起的问题。如在一个四处理器系统中，所有非关键的进程可以被分配到一个 CPU 中，让其他三个 CPU 处理实时应用。

### SCHED_RR 策略

该策略中，优先级相同的进程以循环时间分享的方式执行。进程每次使用 CPU 的时间为一个固定长度的时间片。一旦被调度执行之后，使用 SCHED_RR 策略的进程会保持对 CPU 的控制直到下列条件中的一个得到满足:
- 达到时间片终点了
- 自愿放弃 CPU，这可能是由于执行了一个阻塞式系统调用或调用了 sched_yield() 系统调用
- 终止了
- 被一个优先级更高的进程抢占了

对于上面列出的前两个事件，当运行在 SCHED_RR 策略下的进程丢掉 CPU 之后将会被放置在与其优先级级别对应的队列的队尾。在最后一种情况中，当优先级更高的进程执行结束之后，被抢占的进程会继续执行直到其时间片的剩余部分被消耗完(即被抢占的进程仍然位于与其优先级别对应的队列的队头)。

在 SCHED_RR 和 SCHED_FIFO 两种策略中，当前运行的进程可能会因为下面某个原因而被抢占:
- 之前被阻塞的高优先级进程解除阻塞了(如它所等待的 I/O 操作完成了)
- 另一个进程的优先级被提到了一个级别高于当前运行的进程的优先级的优先级
- 当前运行的进程的优先级被降低到低于其他可运行的进程的优先级了

SCHED_RR 策略与标准的循环时间分享调度算法(SCHED_OTHER)类似，即它也允许优先级相同的一组进程分享 CPU 时间。它们之间最重要的差别在于 SCHED_RR 策略存在严格的优先级级别，高优先级的进程总是优先于低优先级的进程。而在 SCHED_OTHER 策略中，低 nice 值(即高优先级)的进程不会独占 CPU，它仅仅在调度决策时为进程提供了一个较大的权重。它们之间另一个重要的差别是 SCHED_RR 策略允许精确控制进程被调用的顺序。

### SCHED_FIFO 策略

SCHED_FIFO(先入先出)策略与 SCHED_RR 类似，它们之间最主要地差别在于在 SCHED_FIFO 策略中不存在时间片。一旦一个 SCHED_FIFO 进程获得了 CPU 的控制权之后，它就会一直执行直到下面某个条件被满足:
- 自动放弃 CPU
- 终止了
- 被一个优先级更高的进程抢占了

在第一种情况中，进程会被放置在与其优先级级别对应的队列的队尾。在最后一种情况中，当高优先级进程执行结束之后(被阻塞或终止了)，被抢占的进程会继续执行(即被抢占的进程位于与其优先级级别对应的队列的队头)。

### 防止实时进程锁住系统

由于 SCHED_RR 和 SCHED_FIFO 进程会抢占所有低优先级的进程(如运行这个程序的 shell)，因此在开发使用这些策略的应用程序时需要小心可能会发生失控的实时进程因一直占住 CPU 而导致锁住系统的情况。在程序中可以通过一些方法来避免这种情况的发生。

1. 使用 `setrlimit()` 设置一个合理的低软 CPU 时间组员限制。如果进程消耗了太多的 CPU 时间，那么它将会收到一个 `SIGXCPU` 信号，该信号在默认情况下会杀死该进程。
2. 使用 `alarm()` 设置一个警报定时器。如果进程的运行时间超出了由 alarm() 调用指定的秒数，那么该进程会被 `SIGALRM` 信号杀死。
3. 创建一个拥有高实时优先级的看门狗进程。这个进程可以进行无限循环，每次循环都睡眠指定的时间间隔，然后醒来并监控其他进程的状态。这种监控可以包含对每个进程消耗的 CPU 时间的度量(关键字 clock_getcpuclockid 函数)并使用 `sched_getscheduler()` 和 `sched_getparam()` 来检查进程的调度策略和优先级。如果一个进程看起来行为异常，那么看门狗线程可以降低该进程的优先级或向其发送合适的信号来停止或终止该进程。
 