
Linux 进程调度器设计为两层模型，第一层是通用调度器，定义作为调度器入口函数的抽象操作，第二层是调度类，实现实际的调度操作，其中每个类都是专门处理特定种类进程的调度启发式算法。

从 4.12.x 内核开始，Linux 提供了 3 个调度类: 完全公平调度类(CFS)、实时调度类和截止期调度类。每个类处理具有特定调度需求的进程。

通常，运行队列包含了所有的进程，它们在 per-CPU 上争夺 CPU 时间。通用调度器查看运行队列里可以调度的下一个可运行的最佳任务。在设计上，每个调度类都有自己的运行队列数据结构，而所有的调度类又都将它们的运行队列嵌入到通用调度器的 per-CPU 运行队列中。

三种调度类中，截止期类优先级最高，实时类其次，CFS 优先级最低(1^)。通用调度器通过 schedule()->pick_next_task() 遍历选出要运行的下一个最佳任务。如果没有找到可运行的任务，将由 CFS 调用空闲进程。

### 完全公平调度类(CFS)

CFS 基于为每个任务分配的策略(2^)和动态优先级，在给任务分配处理器时间(3^)方面保持平衡。

CFS 的运行队列是一个自平衡的红黑树。红黑树保存了所有竞争进程，最高优先级的进程放置在其最左边的节点上。pick_next_task() 函数会从红黑树中选择最左边的节点来进行调度(^6)。

CFS 在所有执行线程中将调度周期划分为时间片，以避免线程饥饿。同时为了确保拥有较少线程的进程与拥有较多线程的进程所分配的 CPU 时间的公平性，CFS 引入了组调度(group scheduling)，使时间片被分配给线程组而不是单个线程。

### 实时调度类

实时任务的目标是确定性地运行，并希望控制何时被调度和调度多久，因此它们总是优先于普通任务(SCHED_NORMAL)。

实时类的运行队列是一个使用每个优先组值为 1~99 的单链表。在调度静态优先级的进程时，Linux 应用了 SCHED_FIFO(^4) 和 SCHED_RR(^5) 这两个实时策略。

### deadline 调度类

deadline 调度类是 Linux 上 RT 进程的新类别(自 3.14 内核开始添加)。与 FIFO 和 RR 不同的是，进程可能会占用 CPU 或受到时间片的约束，一个 deadline 进程会基于算法预先确定其运行时的需求。

deadline 进程使用 SCHED_DEADLINE 作为其策略元素。

----

(1^) 调度器决定运行哪个进程取决于进程的优先级。在 *nix 系统中，优先级从本质上分为动态优先级和静态优先级两种。动态优先级由内核动态地设置给普通进程，其中考虑了各种因素，如进程的 nice 值、历史行为、失效时间和等待时间。静态优先级被用户设置给实时进程，内核不能改变其优先级。在调度时，具有静态优先级的进程优先级更高。CFS 是动态优先级，实时类和截止期类为静态优先级。

(2^) CFS 使用两种策略来处理所有的普通进程(所有非实时进程都可以归类为普通进程)。
- SCHED_NORMAL(0): 适用于所有普通进程。
- SCHED_BATCH(3): 通常在服务器中，进程是非交互式的，是 CPU 密集型批量处理的。这些 CPU 密集型进程的优先级比 SCHED_NORMAL 进程的优先级低一点，并且它们不会抢占正在调度的普通进程。

(3^) CFS 不依赖传统的时间片来分配处理器时间，而是使用虚拟运行时间(vruntime)的概念: 它表示进程获得 CPU 时间的时间量，这意味着低 vruntime 值表示进程是被处理器剥夺运行时间的，而高 vruntime 值表示该进程获得了相当长的处理器时间。具有低 vruntime 值的进程在调度时会获得最高优先级。

(4^) FIFO 是适用于优先级高于 0(分配给普通进程的优先级为0)的进程的调度机制。FIFO 进程在没有任何时间片分配下运行，也就是说，它们总是在运行，直到被某个事件阻塞或被另一个进程抢占。当调度器遇到多个具有相同优先级的 FIFO 任务时，它会从链表头部的第一个进程开始，以轮询的方式运行进程。在抢占时，该进程会被添加回链表的尾部。如果高优先级进程抢占 FIFO 进程，它将会在链表头部等待，并且当所有其他高优先级任务被抢占后，才会再次启动运行。当新的 FIFO 进程变为可运行时，它会被添加到链表的尾部。

(5^) 轮询策略与 FIFO 类似，唯一的不同是它被分配了一个时间片来运行。这是对 FIFO 的一种改进(因为一个 FIFO 进程可能会运行，直到它主动让出 CPU 或等待)。

(6^) 每个进程必须隐匿或显式地被抢占，以便为另一个进程让路。当一个高优先级进程变为可运行时，会发生抢占。为此，调度器将不得不检查高优先级的可运行线程。程序从中断或系统调用返回时，也需要重新调度。由于有周期性的定时器中断保证定期发生，保证了调度器被调用。当进程进入一个被阻塞或发生中断事件时，也会发生抢占。
