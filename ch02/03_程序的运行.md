
程序的运行分两种情况: 一种是在有操作系统的环境下执行一个应用程序；另一种是在无操作系统的环境下执行一个裸机程序。在不同的环境下执行程序，文件的格式一般也会不一样，如在 Linux 环境下，可执行文件是 ELF 格式，而在裸机环境下执行的程序一般是 BIN/HEX 格式。BIN/HEX 文件是纯指令文件，而 ELF 文件除了基本的代码段、数据段，还有文件头、符号表、program header table 等用来辅助程序运行的信息。

两种程序虽然运行环境不同，文件格式也有所差异，但原理是相通的: 都要将指令加载到内存中的指定位置。而这个指定位置往往又与可执行文件链接时的链接地址有关。

### 操作系统环境下的程序运行

一个装有操作系统的计算机系统，当执行一个应用程序时，首先会运行一个叫作加载器的程序。加载器会根据软件的安装路径信息，将可执行文件从 ROM 中加载到内存，然后进行一些与初始化、动态库重定位相关的操作，最后才跳转到程序的入口运行。在不同的操作系统下，可以由不同的程序充当"加载器"的角色，如在 Linux 命令行模式下运行一个应用程序，类似 sh、bash 这样的 Shell 终端程序就充当加载器的角色: 它们会把程序加载到内存，封装成进程，参与操作系统的调度和运行。

一个可执行文件由不同的 section 组成，分为代码段、数据段、BSS 段等。加载器在加载程序运行时，会将这些代码段、数据段分别加载到内存中的不同位置。可执行文件的文件头提供了文件类型、运行平台、程序的入口地址等基本信息，加载器在加载程序之前会首先根据文件头的信息做一些判断，如果发现程序的运行平台和当前的环境不符，则会报出错处理。

在 Linux 环境下运行的程序一般都会被封装成进程，参与操作系统的统一调度和运行。在 Shell 环境下运行一个程序，Shell 终端程序一般会先 fork 一个子进程，创建一个独立的虚拟进程地址空间，接着调用 execve 函数将要运行的程序加载到进程空间: 通过可执行文件的文件头，找到程序的入口地址，建立进程虚拟地址空间与可执行文件的映射关系，将 PC 指针设置为可执行文件的入口地址，即可启动运行。一般情况下，程序的入口地址可通过下面的计算公式得到:
```s
  程序的入口地址 = 编译时的链接地址 + 一定偏移(程序头等会占用一部分空间)
```
不同的编译器有不同的链接起始地址。在 Linux 环境下，GCC 链接时一般以 0x08040000 为起始地址开始存放代码段，而 ARM GCC 交叉编译器一般以 0x10000 为链接起始地址。紧挨着代码段，从一个 4KB 边界对齐的地址处开始存放数据段。紧挨着数据段，就是 BSS 段。BSS 段后面的第一个 4KB 地址对齐处，就是在程序中使用 malloc()/free() 申请的堆空间。

程序链接时的链接地址其实都是虚拟地址。程序运行时，虽然每个进程的地址空间都是一样的，但是每个进程都有自己的页表，面表里的每一个条目叫面表项，面表项里存储的是虚拟地址和物理地址之间的映射关系，相同的虚拟地址经过 MMU 硬件转换后，会分别映射到物理内存的不同区域，从而彼此相互隔离和独立。

对于每一个运行的进程，Linux 内核都会使用一个 task_struct 结构体来表示，多个结构体通过指针构成链表。操作系统基于该链表就可以对这些进程进行管理、调度和运行。不同进程的代码段和数据段分别存储在物理内存不同的物理页上，进程间彼此独立，通过上下文切换，轮流占用 CPU 去执行自己的指令。

### 裸机环境下的程序运行

在一个裸机平台下，系统上电后，没有程序运行的环境，需要借助第三方工个将程序加载到内存，然后才能正常运行。

在一个嵌入式 Linux 系统中，Linux 内核镜像的运行其实就是裸机环境下的程序运行。Linux 内核镜像一般会借助 U-boot 这个加载工具将其从 Flash 存储分区加载到内存中运行，U-boot 在 Linux 启动过程中扮演了"加载器"的角色。

U-boot 自身也和 Linux 内核镜像一样，存储在 NAND/NOR 分区上。在 U-boot 启动过程中，不仅要完成本身代码的"自复制": 将自身代码从存储分区复制到内存中，还要完成自身代码的重定位，一般具备这种功能的代码称之为"自举"。

在嵌入式系统中，经常会使用 U-boot 来引导 Linux 内核启动。U-boot 不仅充当"加载器"的角色，引导 Linux 内核镜像运行，还充当了"链接器"的角色，完成自身代码的复制和重定位。

### 程序入口

编译器在编译一个工程时，默认的程序入口是 `_start` 符号，而不是 main。符号 main 是一个约定符号，它用来告诉编译器在一个项目中哪里是程序的入口点。

C 语言函数调用过程中的参数传递、函数内部的局部变量都是保存在栈中的，没有栈 C 语言就无法运行，因此在运行 main() 函数之前必须先运行一段汇编代码来初始化堆栈环境。设置好堆栈指针后，这部分代码还要继续初始化一些环境，如初始化 data 段的内容，初始化 static 静态变量和 global 全局变量，并给 BSS 段的变量赋初值: 未初始化的全局变量中，int 类型的全部初始化为 0，布尔型的变量初始化为 FALSE，指针型的变量初始化为 NULL。完成初始化环境后，这部分代码还会将用户传入的参数传递给 main，最后才跳入 main() 函数运行。

这部分初始化代码是在程序编译阶段，由编译器自动添加到可执行文件中的。编译器厂商在开发编译器时，除了实现 C 语言标准中规定的 printf、fopen、fread 等标准函数，还会实现这部分初始化代码，完成进入 main() 函数之前的一系列化初始化操作。
- C 语言运行的基本堆栈环境、进程环境。
- 动态库的加载、释放、初始化、清理等工作。
- 向 main() 函数传参 argc、argv，调用 main() 函数执行。
- 在 main() 函数退出后，调用 exit() 函数，结束程序的运行。
