
库分为静态库和动态库两种。如果在项目中引用了库函数，则在编译时，链接器会将引用的函数代码或变量，链接到可执行文件里，和可执行程序组装在一起，这种库被称为静态库，即在编译阶段链接的库。动态库在编译阶段不参与链接，不会和可执行文件组装在一起，而是在程序运行时才被加载到内存参与链接，因此又叫作动态链接库。

### 链接静态库

静态库的本质其实就是可重定位目标文件的归档文件。静态库使用 ar 命令就可以将多个目标文件打包为一个静态库。
```c
  // test.c
  int add(int a, int b) { return a + b; }
  int sub(int a, int b) { return a - b; }
  int mul(int a, int b) { return a * b; }
  int div(int a, int b) { return a / b; }
  
  // main.c
  int add(int, int);
  int main()
  {
    int sum = 0;
    sum = add(1,2);
    return 0;
  }
```
对上面的文件执行如下操作:
```s
  gcc -c test.c  // 生成目标文件
  ar rcs libtest.a test.o // 将 test.o 打包成静态库
  gcc main.c -L. -ltest // 指定要链接的库的名字和路径，产生可执行程序 a.out
```
使用 ar 命令制作静态库时，一些常用的参数如下:
- -c: 禁止在创建库时产生的正常消息
- -r: 如果指定的文件已经在库中存在，则替换它
- -s: 无论库是否更新都强制重新生成新的符号表
- -d: 从库中删除指定的文件
- -o: 对压缩文档成员进行排序
- -q: 向库中追加指定文件
- -t: 打印库中的目标文件
- -x: 解压库中的目标文件

编译器是以源文件为单位编译程序的，链接器在链接过程中逐个对目标文件进行分解组装。如果实际可执行文件只使用了一小部分目标文件内容，那么将所有的目标文件都编译进去只会让最终的可执行文件体积增大。解决的办法是在封装函数库时，将每个函数都单独使用一个源文件实现，然后将多个目标文件打包即可。
```c
  // add.c
  int add(int a, int b) { return a + b; }
  // sub.c
  int sub(int a, int b) { return a - b; }
  // mul.c
  int mul(int a, int b) { return a * b; }
  // div.c
  int div(int a, int b) { return a / b; }
  // main.c
  int add(int, int);
  int main()
  {
    int sum = add(1, 2);
    return 0;
  }
```

### 动态链接

静态链接库的缺点是: 生成的可执行文件体积较大，当多个程序引用相同的公共代码时，这些公共代码会多次加载到内存，浪费内存资源，尤其对于一些内存配置较低的嵌入式系统。

动态链接对一些公用的代码、如库，在链接期间暂不链接，而是推迟到程序运行时再进行链接。这些在程序运行时才参与链接的库被称为动态链接库。程序运行时，除了可执行文件，这些动态链接库也要跟着一起加载到内存，参与链接和重定位过程，否则程序可能就会报未定义错误，无法运行。

比如对于上面的代码，可以通过如下操作编译成动态库，进而链接生成可执行文件:
```s
  gcc -fPIC -shared add.c sub.c mul.c div.c -o libtest.so
  gcc main.c libtest.so
```

在 Linux 环境下，当运行一个程序时，操作系统首先会给程序 fork 一个子进程，接着动态链接器被加载到内存，操作系统将控制权交给动态链接器，让动态链接器完成动态库的加载和重定位操作，最后跳转到要运行的程序。

动态链接需要考虑的一个重要问题是加载地址。一个静态链接的可执行文件在运行时，一般加载地址等于链接地址，而且这个地址是固定的。动态链接库加载到内存中的地址则是随机的，因为每一个可执行文件的大小不同，加载到内存后剩余的地址空间也不尽相同，动态链接库的地址要根据进程地址空间的实际空闲情况随机分配。动态链接通过装载时重定位来解决动态链接库被加载到内存后，目标文件的起始地址发生变化的问题。这种操作虽然解决了可执行文件中绝对地址的引用问题，但也带来了另外一个问题: 对于每个进程，动态库被加载到了内存的不同地址，也只能被进程自身共享，无法在多个进程间共享，无法节省内存，违背了动态库的设计初衷。

如果想让动态库放到内存的任何位置都可以运行，都可以被多个进程共享，一种比较好的方法是将动态库设计成与地址无关的代码，这可以通过 `-fPIC` 参数生成的指令来实现。

如果把所有的动态库一次性全部加载到内存并一一对它们进行重定位，会耗费不少的时间。程序中存在大量的 if-else 分支，并不是所有的指令都能执行到，如果加载到内存的动态库没有被调用到，这又会浪费内存空间。基于这个原因，可执行文件一般都采用延迟绑定: 程序在运行时不会立即把所有的动态库都加载到内存中并进行重定位，当动态库中的函数第一次被调用到时，才会把用到的动态库加载到内存中并进行重定位。

程序安装时，可执行文件会复制到 Linux 系统的默认路径下，这些路径由环境变量 PATH 管理和维护。可执行文件依赖的共享库一般要放到库的默认路径下面，如 `/lib`、`/usr/lib` 等。动态链接器会到系统默认路径下去查找`共享库`，此外也会到用户指定的一些路径下去查找，用户可以在 `/etc/ld.so.conf` 文件中添加自己的共享库路径。为了减少每次查找文件的时间消耗，/etc/ld.so.conf 修改后，也可以使用 ldconfig 命令生成一个缓存 `/etc/ld.so.cache` 以提高查找效率。每当新增、删除或修改共享库的路径时，使用 ldconfig 更新一下缓存就可以了。

系统在的所有程序在运行时，都会按照上面的这种方式查找共享库。有时候也可以使用 LD_LIBRARY_PATH 环境变量临时改变共享库的查找路径，而不会影响系统中的其他应用程序。
```s
  export LD_LIBRARY_PATH=/home/wit/lib:/usr/test/lib
```

### 插件的工作原理

插件的本质就是共享动态库: 主程序框架引用外部模块符号，运行时以动态链接库的形式加载进来并进行重定位，就可以直接调用了。

Linux 提供了专门的系统调用接口，支持显式加载和引用动态链接库，常用的系统调用 API 如下。

1) 加载动态链接库

```c
  void *dlopen(const char* filename, int flag);
  void *Handle = dlopen("./libtest.so", RTLD_LAZY);
```
dlopen() 函数返回一个 `void*` 类型的操作句柄，通过这个句柄就可以操作显式加载到内存中的动态库。函数的第一个参数是要打开的动态链接库，第二个参数是打开标志位，经常使用的标志位有如下几种:
- RTLD_LAZY: 解析动态库遇到未定义符号不退出，仍继续使用。
- RTLD_NOW: 遇到未定义符号，立即退出。
- RTLD_GLOBAL: 允许导出符号，在后面其他动态库中可以引用。

2) 获取动态对象地址

```c
  void *dlsym(void* handle, char* symbol);
  void (*funcp)(int, int);
  funcp = (void(*)(int,int)) dlsym(Handle, "myfunc");
```
dysym() 函数根据动态链接库句柄和要引用的符号，返回符号对应的地址。

3) 关闭动态链接库

```c
  int dlclose(void* Handle);
```
该函数会将加载到内存的共享库的引用计数减一，当引用计数为 0 时，该动态共享库便会从系统中被卸载。

4) 动态库错误函数

```c
  const char* dlerror(void);
```
当动态链接库操作函数失败时，dlerror 将返回出错信息。若没有出错，则 dlerror 的返回值为 NULL。

[示例代码](t/dynamic)
