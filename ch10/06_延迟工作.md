
中断管理中，下半部是执行延迟工作的内核机制，并可由任何内核代码使用来延迟执行非关键工作，直到将来的某个时候。为了支持其实现和延迟例程的管理，内核实现了特殊的框架，称为 softirq、tasklet 和工作队列。

### softirq

softirq 一般翻译为软中断，由该框架管理的延迟例程以高优先级执行，但是其硬中断线路是启用的。因此，softirq 下半部(或 softirq)可以抢占除硬中断处理程序外的所有其他任务。但是，softirq 的使用仅限于静态内核代码，该机制不能用于动态内核模块。

每个 softirq 都由一个在内核头文件<linux/interrupt.h>中声明的 struct softirq_action 类型的实例表示。这个结构体包含一个保存下半部例程的地址的函数指针:
```c
struct softirq_action
{
  void (*action)(struct softirq_action *);
};
```
目前内核版本有 10 个 softirq，通过枚举变量来索引，索引号作为 softirq 的相对优先级，低索引对应高优先级，0 索引是最高优先级的 softirq:
```c
enum {
  HI_SOFTIRQ=0,
  TIMER_SOFTIRQ,
  NET_TX_SOFTIRQ,
  NET_RX_SOFTIRQ,
  BLOCK_SOFTIRQ,
  IRQ_POLL_SOFTIRQ,
  TASKLET_SOFTIRQ,
  SCHED_SOFTIRQ,
  HRTIMER_SOFTIRQ,
  RCU_SOFTIRQ,
  NR_SOFTIRQS
};
```
内核源文件<kernel/softirq.c>声明了一个大小为 NR_SOFTIRQS 的 softirq_vec 数组，每个偏移量包含一个 softirq_action 实例，对应于枚举变量中索引的 softirq:
```c
static struct softirq_action softirq_vec[NR_SOFTIRQS];
__cacheline_aligned_in_smp;

/* string constants for naming each softirq */
const char * const softirq_to_name[NR_SOFTIRQS] = {
  "HI", "TIMER", "NET_TX", "NET_RX", "BLOCK", "IRQ_POLL",
  "TASKLET", "SCHED", "HRTIMER", "RCU"
};
```
softirq 框架提供一个 open_softirq() 函数，用于初始化 softirq 实例中对应的下半部例程:
```c
void open_softirq(int nr, void (*action)(struct softirq_action *))
{
  softirq_vec[nr].action = action;
}
```
nr 是要初始化的 softirq 对应的索引。*action 是一个函数指针，初始化为下半部例程的地址。例如为定时器服务注册一个 softirq:
```c
/* kernel/time/timer.c */
open_softirq(TIMER_SOFTIRQ, run_timer_softirq);
```
内核服务能够通过一个 raise_softirq() 函数给 softirq 处理程序发出执行信号。该函数将 softirq 的索引作为参数:
```c
void raise_softirq(unsigned int nr)
{
  unsigned long flags;

  local_irq_save(flags);
  raise_softirq_irqoff(nr);
  local_irq_restore(flags);
}
```
以下代码片段来自<kernel/time/timer.c>:
```c
void run_local_timers(void)
{
  struct timer_base *base = this_cpu_ptr(&amp; timer_based[BASE_STD]);

  hrtimer_run_queues();
  /* Raise the softirq only if required. */
  if (time_before(jiffies, base->clk)) {
    if (!IS_ENABLED(CONFIG_NO_HZ_COMMON) || !base->nohz_active)
      return;
    /* CPU is awake, so check the deferrable base. */
    base++;
    if (time_before(jiffies, base->clk))
      return;
  }
  rasie_softirq(TIMER_SOFTIRQ);
}
```
内核维护一个 per-CPU 位掩码，用于跟踪已引发执行的 softirq，然后 raise_softirq() 函数在本地 CPU softirq 的位掩码中设置相应的位，以标记待处理的 softirq。

内核代码在多处不同的位置检查并执行待处理的 softirq 处理程序。原则上，它们在中断上下文中执行，在启用 IRQ 线的硬中断处理程序执行完后立即执行。这保证了迅速处理引发自硬中断处理程序的 softirq，从而实现了最佳的缓存使用率。然而，内核允许任意任务在本地处理器上通过 local_bh_disable() 或 spin_lock_bh() 调用来挂起执行 softirq。待处理的 softirq 处理程序在通过调用 local_bh_disable() 或 spin_unlock_bh() 来重新启用 softirq 的任意任务的上下文中执行。最后，softirq 处理程序也可以由 per-CPU 内核线程 ksoftirqd 执行，当一个 softirq 被任意进程上下文的内核例程引发时，该线程就会被唤醒。当由于高负载而累积了很多 softirq 时，该线程也会从中断上下文唤醒。内核线程 ksoftirqd 包含了所有的软中断处理逻辑。

由于 softirq 是在硬中断处理程序完成后立即运行，因此它最适合完成硬中断处理程序延迟的优先工作。但是，softirq 处理程序是可重入的，如果有的话，在访问数据结构时必须使用适当的保护机制。softirq 的可重入特性可能会导致无限制的延迟，而影响整个系统的效率，这就是它们的使用受到限制的原因，而且新的 softirq 几乎不会被添加，除非执行高频线程化的延迟工作是绝对必要的。对于所有其他类型的延迟工作，建议使用 tasklet 和工作队列。

### tasklet


### 工作队列