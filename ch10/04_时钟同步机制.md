
### 时钟源多级缓存层次化同步架构示意

```c
Global Clock Source (HPET/ACPI PM Timer)
        |
        v
     Timekeeper
        |
    |---------|
    v         v
CPU0 Clock  CPU1 Clock  // Per-CPU 时钟事件设备
```

### 时钟同步流程 - 初始化阶段

- 1.检测并选择最佳时钟源(硬件抽象: HPET > TSC > PIT)
- 2.初始化全局 timekeeper
- 3.设置每个 CPU 的本地 APIC 定时器
- 4.校准各个时钟源(calibrate_tsc()等)

timekeeper多核同步的关键技术:
- 1.使用序列化锁保证读取一致性
- 2.过RCU(读取-复制-更新)机制切换时钟源
- 3.通过内存屏障确保时间更新的可见性

内核使用硬件时钟源来更新软件计数器:

|             硬件时钟源            |   精度  |     特点         |      使用场景    |
|:--------------------------------|:--------|:----------------|:----------------|
| TSC(Time Stamp Counter)         |	~1ns	  |CPU 内部计数器，最快| 现代 x86 系统默认 |
| HPET(High Precision Event Timer)|	~100ns  |独立硬件，稳定      | 备用或旧系统      |
| ACPI PMT(Power Management Timer)|	~300ns	|省电，精度低	       | 移动设备         |
| RTC(Real Time Clock)            |	~1ms	  |电池供电，持久化    | 系统启动初始化     |

多核时间不宜再用 x86 的 RDTSC 指令测试指令周期和时间，原因如下:
- 1.不能保证同一块主板上每个核的 TSC 是同步的。每个核心拥有一个 RDTSC，不能保证每个核心在同一时刻启动 RDTSC 计时，又由于 cpu 抢占机制，所读取的当前 RDTSC 未必时原有的 RDTSC。
- 2.CPU 的时钟频率可能变化，例如笔记本的节能模式。
- 3.乱序执行导致 RDTSC 测得的周期数不准。

```s
# 查看系统的时钟源
cat /sys/devices/system/clocksource/clocksource0/current_clocksource
# 通常输出：tsc 或 hpet

# 查看可用时钟源
cat /sys/devices/system/clocksource/clocksource0/available_clocksource
```

### 时钟同步流程 - 运行时阶段

示例代码如下:
```c
void sync_cpu_clock(int cpu)
{
  struct timekeeper *tk = &timekeeper;
  u64 now;
  
  // 1. 从全局timekeeper获取基准时间
  now = tk->tkr_mono.read(tk->tkr_mono.clock);
  
  // 2. 考虑时钟偏移和漂移(CPU间的时间同步)
  now += per_cpu(cpu_offset, cpu);
  
  // 3. 设置Per-CPU时钟
  per_cpu(cpu_clock, cpu) = now;
  
  // 4. 内存屏障确保同步
  smp_wmb();
}
```

关键同步点:
```c
// 1. tick_do_update_jiffies64() - 更新全局jiffies
static void tick_do_update_jiffies64(ktime_t now)
{
  unsigned long ticks = 0;
  ktime_t delta;
  
  // 计算自上次更新以来的tick数
  delta = ktime_sub(now, last_jiffies_update);
  
  // 更新全局jiffies（使用seq锁保护）
  write_seqlock(&jiffies_lock);
  do {
    ticks++;
    jiffies_64++;
  } while (time_after(now, last_jiffies_update));
  write_sequnlock(&jiffies_lock);
}

// 2. 更新Per-CPU的时间
void update_process_times(int user_tick)
{
  // 更新进程统计
  account_process_tick(p, user_tick);
  
  // 触发软定时器
  run_local_timers();
  
  // 调度器tick
  scheduler_tick();
}
```

### 各级缓存结构

Timekeeper 作为全局时间保持器，是时间存储的核心位置(内核维护)。
```c
struct timekeeper {
  /* 主要时钟源和读取器 */
  struct tk_read_base tkr_mono;    // 单调时钟（系统启动后的纳秒数）
  struct tk_read_base tkr_raw;     // 原始单调时钟
  struct clocksource *clock;       // 当前活动的时钟源
  
  /* 存储的时间值 */
  u64                     xtime_sec;      // 从1970-01-01开始的秒数
  unsigned long           ktime_sec;      // 单调时间的秒部分
  struct timespec64       wall_to_monotonic; // 墙钟到单调时间的偏移
  
  /* 更新时间相关 */
  ktime_t                 offs_real;      // 墙钟偏移
  ktime_t                 offs_boot;      // 启动时间偏移
  
  /* 同步保护 */
  seqcount_t              seq;            // 序列锁
  raw_spinlock_t          raw_lock;       // 原始自旋锁
};
```

每个CPU都有自己的时间缓存(Per-CPU时间缓存)，减少了全局锁竞争，是性能的关键。
```c
struct vsyscall_gtod_data {
  seqcount_t      seq;            // 序列号，用于无锁读取
  
  // 缓存的时间值
  u64             clock_monotonic_time;   // 单调时间（纳秒）
  u64             clock_realtime_time;    // 实时时间（纳秒）
  u64             clock_boottime_time;    // 启动时间（纳秒）
  
  // 用于计算的参数
  u64             cycle_last;             // 最后读取的时钟周期
  u64             mask;                   // 时钟源掩码
  u32             mult;                   // 乘数
  u32             shift;                  // 移位数
  
  // 基础时间
  long            tz_minuteswest;         // 时区
  int             tz_dsttime;             // 夏令时
  u32             use_syscall;            // 是否使用系统调用
};
```

用于空间可以从VDSO(虚拟动态共享对象)区域直接读取数据计算出时间，无系统调用开销。
```c
struct vdso_data {
  // 时间相关字段（与vsyscall_gtod_data类似）
  u64         cycle_last;
  u64         mask;
  u32         mult;
  u32         shift;
  u64         basetime[VDSO_BASES];  // 各种时间基准
  u32         seq;                   // 序列号
};
```

### 用户层读取时间路径

以 gettimeofday 函数为例。

1.系统调用路径
```s
用户态 gettimeofday()
    ↓
触发软中断(int 0x80 或 syscall指令)
    ↓
保存寄存器，切换到内核态
    ↓
查找系统调用表，调用sys_gettimeofday()
    ↓
获取锁，读取timekeeper，计算时间
    ↓
复制结果到用户空间
    ↓
恢复寄存器，切换回用户态
    ↓
返回结果
```

开销: 通常 > 100ns，涉及2次上下文切换

2.VDSO路径

```s
用户态 gettimeofday()
    ↓
调用VDSO页面中的__vdso_gettimeofday(如果可用)
    ↓
读取Per-CPU缓存的 vsyscall_gtod_data
    ↓
使用缓存的参数计算当前时间
    ↓
返回结果
```

开销: 通常 10-30ns，无上下文切换

### 拓展: clock_gettime 函数

clock_gettime 函数可以从不同的时钟源获取时间，精度可达纳秒级。