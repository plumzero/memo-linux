
### 中断信号和向量

中断是传递给处理器的信号 ，表示发生了一个需要立即给予关注的重大事件。这些信号可能来源于外部硬件(连接到系统)或者处理器内部电路。

当中断来自外部设备时，它称为硬件中断(hardware interrupt)。这些信号是由外部硬件产生以引起处理器注意一个重要的外部事件的发生。(^1)

由于正在执行的程序指令生成的事件而在 CPU 内部触发的中断称为软件中断(software interrupt)。一个软件中断是由正在执行的程序指令触发的异常引起的，或者是由正在执行的特权指令触发的中断。(^2)

为了响应中断事件的发生，CPU 被设计为抢占当前的指令序列或执行线程，并执行一个特殊的函数，称为中断服务例程(ISR)。为了找到一个中断事件对应的 ISR，需要使用中断向量表(interrupt vector table)。一个中断向量表是一个内存地址，它包含了一个软件定义的中断服务的引用，作为一个中断的响应而被执行。

### 可编程中断控制器

CPU 采用专用输入引脚设计(intr 引脚)用于接收外部中断信号。每个能够发出中断请求的外部硬件设备通常都包含一个或多个输出引脚，称为中断请求(IRQ)线，用于发出中断请求信号给 CPU。所有计算平台使用一个称为可编程中断控制器(PIC)的硬件电路，在各种中断请求线上复用 CPU 的中断引脚。所有现有的来自板上设备控制器 IRQ 线都被路由到中断控制器的输入引脚，该中断控制器监控每个 IRQ 线上的中断信号，并在中断请求到达时，把请求转换成一个 CPU 可以理解的向量号，并将中断信号传递给 CPU 的中断引脚。简而言之，就是一个可编程中断控制器将多个设备中断请求线复用到处理器的单个中断线。
```s
+--------+   IRQ    +-----+
| 以太网  +--------->+     |
+--------+          |     |
                    |     |          +------+
+--------+   IRQ    |     |  向量号   |      |
| 磁  盘  +--------->+ PIC +--------->+ CPU  |
+--------+          |     |      intr|      |
                    |     |          +------+
+--------+   IRQ    |     |
| 时  钟  +--------->+     |
+--------+          +-----+
```

中断控制器的设计和实现是和特定平台相关的。体系结构相关的内核代码分支实现了特定的中断控制器操作用于管理 IRQ 线，例如屏蔽/取消屏蔽单独的中断，设置优先级和 SMP 亲和力。内核通过 struct irq_chip(include/linux/irq.h) 定义了一个体系结构无关的抽象层，这样就可以简单地操作单个 IRQ 线。

中断控制器使用唯一的硬件 IRQ 号来标识每个 IRQ 源。内核的通用中断管理层把每个硬件 IRQ 映射成唯一的标识符，称为 Linux IRQ。所有外围设备驱动程序被编程为使用 Linux IRQ 号来绑定或注册它们的中断处理程序。Linux IRQ 由 IRQ 描述符结构体表示，该结构体由 struct irq_desc 定义。IRQ 描述符列表在一个索引为 IRQ 号的数组中维护，称为 IRQ 描述符表。

### 高级中断管理接口

通用的 IRQ 层为设备驱动程序提供了一组功能接口来抓取 IRQ 描述符并绑定中断处理程序、释放 IRQ、启用或禁用中断线等。

注册一个中断处理程序:
```c
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char* name, void *dev);
```
request_irq() 通过传进来的参数实例化一个 irqaction 对象，并把它绑定到第一个参数(irq)指定的 irq_desc。这个调用分配中断资源并启用该中断线和 IRQ 处理程序。handler 是一个 irq_handler_t 类型的函数指针，指向驱动程序特定的中断处理程序的地址。flags 是一个和中断管理相关的选项的位掩码。

中断处理程序(irq_handler_t)的函数原型如下:
```c
irqreturn_t handler(int irq, void* dev_id);
```
irq 指定 IRQ 号，dev_id 是在注册处理程序时使用的唯一的 cookie。irqreturn_t 是一个整型常量枚举类型的 typedef:
```c
enum irqreturn {
  IRQ_NONE = (0 << 0),
  IRQ_HANDLED = (1 << 0),
  IRQ_WAKE_THREAD = (1 << 1),
};
```
中断处理程序应该返回 IRQ_NONE 来表示中断没有被处理。当中断处理正常完成时，它必须返回 IRQ_HANDLED 以表示成功。IRQ_WAKE_THREAD 是一个特殊标志，被返回以唤醒线程处理程序。

通过 request_irq() 注册的处理程序由内核的中断处理代码路径执行。该代码路径是异步的，并通过挂起本地处理器的调度器抢占以及硬件中断来运行，所以被称为硬 IRQ 上下文。因此，编写短的(尽可能少的工作)和原子的(非阻塞)驱动程序的中断处理程序非常重要，以确保系统的响应性。但是，并不是所有的硬件中断处理程序都是短的和原子的，有大量的复杂设备产生的中断事件，其响应涉及复杂的时变操作。传统上，驱动程序被编程为通过中断处理程序的分离处理程序来处理这种复杂情况，称为上半部(top half)(3^)和下半部(bottom half)(4^)。内核提供了多个机制来调度和执行下半部例程，每个例程都有一个独特的 API 和执行策略。其中，内核支持设置可以在线程上下文中执行的线程化中断处理程序(threaded interrupt handler)来作为使用正规的下半部机制的备选项。驱动程序可以通过一个备选的 request_threaded_irq() 接口来设置线程化中断处理程序:
```c
int request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long irqflags, const char *devname, void *dev_id);
```
分配给 handler 的函数充当在硬 IRQ 上下文执行的主要中断处理程序。分配给 thread_fn 的例程在线程上下文中执行，并且当主处理程序返回 IRQ_WAKE_THREAD 时被调度执行(5^)。handler 为 NULL 时调用该函数将导致内核使用默认的主处理程序，该处理程序只是简单地返回 IRQ_WAKE_THREAD。thread_fn 为 NULL 时调用该函数，其功能和 request_irq() 是相同的。
```c
static inline int __must_check request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char* name, void *dev)
{
  return request_threaded_irq(irq, handler, NULL, flags, name, dev);
}
```

通用 IRQ 层提供函数来执行 IRQ 线路上的控制操作。以下是用于屏蔽和取消屏蔽特定 IRQ 线的函数列表:
```c
void disable_irq(unsigned int irq);
```
这个函数通过操纵 IRQ 描述符结构体中的计数器来禁用指定的 IRQ 线。这个例程有可能是阻塞的调用，因为它要等待直到此中断正在运行的处理程序完成。或者，函数 disable_irq_nosync() 也可用于禁用给定的 IRQ 线，这个调用没有检查并等待给定中断线的任何正在运行的处理程序完成:
```c
void disable_irq_nosync(unsigned int irq);
```
已禁用的 IRQ 线可以通过调用如下函数来启用(6^):
```c
void enable_irq(unsigned int irq);
```

作为选择，中断也可以在本地 CPU 上启用或者禁用。如下成对的宏可以用于相同的情况。
- local_irq_disable(): 禁用本地处理器上的中断。
- local_irq_enable(): 启用本地处理器上的中断。
- local_irq_save(unsigned long flags): 通过保存当前中断状态到 flags 变量来禁用本地处理器上的中断。
- local_irq_restore(unsigned long flags): 通过恢复之前的中断状态来启用本地处理器上的中断。

注销一个中断处理程序:
```c
const void *free_irq(unsigned int irq, void *dev_id);
```
这个函数是一个潜在的阻塞调用，不能从一个中断上下文里调用，它会阻塞调用上下文，直到当前正在执行的指定 IRQ 线的中断处理程序完成。

----
(1^) 例如，在键盘上按下一个键，点击鼠标按钮，或移动鼠标来触发硬件中断，从而通知处理器需要读取的数据现在可用。相对于处理器时钟，硬件中断是异步发生的(意味着它们可以随机发生)，因此也被称为异步中断(asynchronous interrupt)。

(2^) 例如，当一个程序指令试图将一个数字除以零时，处理器的算术逻辑单元引发一个称为除零异常的中断。类似地，当执行中的程序打算调用一个内核服务时，它会执行一个特殊指令(sysenter)，该指令引发一个中断来把处理器转换为特权模式。这些事件与处理器的时钟同步发生，因此也称为同步中断(synchronous interrupt)。

(3^) 上半部例程在硬中断上下文中被调用，并且这些函数被编程执行关键中断操作，例如硬件寄存器上的物理 I/O 操作，并调度下半部延迟执行。

(4^) 下半部例程通常编程为处理剩余的中断关键操作和延迟工作，例如处理上半部生成的数据，与进程上下文交互，以及访问用户地址空间。

(5^) 通过这种分离处理程序设置，有两种可能的情况: 一种是主处理程序可以通过编程来执行关键的中断工作，并将非关键工作延迟到线程处理程序中，并限制主处理程序仅用于验证中断源并唤醒线程。这种情况可能需要相应的中断线被屏蔽直到完成线程处理程序，以避免中断嵌套。这可以通过编程让主处理程序在唤醒线程处理程序之前关闭中断来完成，或者在注册线程中断处理程序时设置一个 IRQF_ONESHOT 标志位。(IRQF_ONESHOT 使硬 IRQ 处理程序结束后，中断不会被重新启用。这是由线程中断使用的，其需要保持禁用 IRQ 线直到线程处理程序执行完成。)

(6^) IRQ 启用和禁用操作的嵌套，即禁用一个 IRQ 线的多个调用需要相同数量的启用调用，才能重新启用这个 IRQ。这意味着对于某个特定的 IRQ，只有当对它的调用与最后一次的禁用操作相匹配时，enable_irq() 才能启用这个 IRQ。
